/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class FormsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44312";
    }

    getForms(  cancelToken?: CancelToken | undefined): Promise<FormListAm> {
        let url_ = this.baseUrl + "/api/v1/core/forms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetForms(_response);
        });
    }

    protected processGetForms(response: AxiosResponse): Promise<FormListAm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FormListAm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FormListAm>(<any>null);
    }

    create(command: CreateFormCommand , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/core/forms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    update(command: UpdateFormCommand, id: string , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/core/forms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    get(id: string , cancelToken?: CancelToken | undefined): Promise<FormAm> {
        let url_ = this.baseUrl + "/api/v1/core/forms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<FormAm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FormAm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FormAm>(<any>null);
    }
}

export class OrderClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44312";
    }

    getOrders(  cancelToken?: CancelToken | undefined): Promise<OrderListAm> {
        let url_ = this.baseUrl + "/api/Order";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrders(_response);
        });
    }

    protected processGetOrders(response: AxiosResponse): Promise<OrderListAm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrderListAm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderListAm>(<any>null);
    }

    create(command: CreateOrderCommand , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    update(command: UpdateOrderCommand, id: string , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Order/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class PositionsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44312";
    }

    getPositions(  cancelToken?: CancelToken | undefined): Promise<PositionListAm> {
        let url_ = this.baseUrl + "/api/v1/core/positions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPositions(_response);
        });
    }

    protected processGetPositions(response: AxiosResponse): Promise<PositionListAm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PositionListAm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PositionListAm>(<any>null);
    }

    create(command: CreatePositionCommand , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/core/positions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    update(command: UpdatePositionCommand, id: string , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/core/positions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    get(id: string , cancelToken?: CancelToken | undefined): Promise<PositionAm> {
        let url_ = this.baseUrl + "/api/v1/core/positions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PositionAm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PositionAm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PositionAm>(<any>null);
    }

    delete(id: string , cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/v1/core/positions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class SystemSettingsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44312";
    }

    update(command: SaveSystemSettingsCommand , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/SystemSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    get(  cancelToken?: CancelToken | undefined): Promise<SystemSettings> {
        let url_ = this.baseUrl + "/api/SystemSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<SystemSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SystemSettings.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SystemSettings>(<any>null);
    }
}

export class UserClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44312";
    }

    authenticate(model: AuthenticateRequest , cancelToken?: CancelToken | undefined): Promise<AuthenticateResponse> {
        let url_ = this.baseUrl + "/api/User/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: AxiosResponse): Promise<AuthenticateResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResponse>(<any>null);
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class WeatherForecastClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44312";
    }

    get(  cancelToken?: CancelToken | undefined): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WeatherForecast[]>(<any>null);
    }
}

export class FormListAm implements IFormListAm {
    items?: FormDetailListAm[] | undefined;

    constructor(data?: IFormListAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FormDetailListAm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormListAm {
        data = typeof data === 'object' ? data : {};
        let result = new FormListAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFormListAm {
    items?: FormDetailListAm[] | undefined;
}

export class FormDetailListAm implements IFormDetailListAm {
    id!: string;
    identityNumber!: number;
    name?: string | undefined;
    description?: string | undefined;
    formActive?: AvailableDate | undefined;
    isActive!: boolean;
    formType?: string | undefined;
    deliveryPrice?: number | undefined;
    placeOnList!: number;

    constructor(data?: IFormDetailListAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.identityNumber = _data["identityNumber"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.formActive = _data["formActive"] ? AvailableDate.fromJS(_data["formActive"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.formType = _data["formType"];
            this.deliveryPrice = _data["deliveryPrice"];
            this.placeOnList = _data["placeOnList"];
        }
    }

    static fromJS(data: any): FormDetailListAm {
        data = typeof data === 'object' ? data : {};
        let result = new FormDetailListAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["identityNumber"] = this.identityNumber;
        data["name"] = this.name;
        data["description"] = this.description;
        data["formActive"] = this.formActive ? this.formActive.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["formType"] = this.formType;
        data["deliveryPrice"] = this.deliveryPrice;
        data["placeOnList"] = this.placeOnList;
        return data; 
    }
}

export interface IFormDetailListAm {
    id: string;
    identityNumber: number;
    name?: string | undefined;
    description?: string | undefined;
    formActive?: AvailableDate | undefined;
    isActive: boolean;
    formType?: string | undefined;
    deliveryPrice?: number | undefined;
    placeOnList: number;
}

export class AvailableDate implements IAvailableDate {
    from?: Date | undefined;
    to?: Date | undefined;

    constructor(data?: IAvailableDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AvailableDate {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAvailableDate {
    from?: Date | undefined;
    to?: Date | undefined;
}

export class CreateFormCommand implements ICreateFormCommand {
    name?: string | undefined;
    description?: string | undefined;
    positions?: string[] | undefined;
    availableDates?: AvailableDate[] | undefined;
    paymentMethods?: number[] | undefined;
    availableLocations?: Location[] | undefined;
    formActive?: AvailableDate | undefined;
    isActive!: boolean;
    formType!: FormTypeEnum;
    deliveryPrice?: number | undefined;
    placeOnList!: number;

    constructor(data?: ICreateFormCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions!.push(item);
            }
            if (Array.isArray(_data["availableDates"])) {
                this.availableDates = [] as any;
                for (let item of _data["availableDates"])
                    this.availableDates!.push(AvailableDate.fromJS(item));
            }
            if (Array.isArray(_data["paymentMethods"])) {
                this.paymentMethods = [] as any;
                for (let item of _data["paymentMethods"])
                    this.paymentMethods!.push(item);
            }
            if (Array.isArray(_data["availableLocations"])) {
                this.availableLocations = [] as any;
                for (let item of _data["availableLocations"])
                    this.availableLocations!.push(Location.fromJS(item));
            }
            this.formActive = _data["formActive"] ? AvailableDate.fromJS(_data["formActive"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.formType = _data["formType"];
            this.deliveryPrice = _data["deliveryPrice"];
            this.placeOnList = _data["placeOnList"];
        }
    }

    static fromJS(data: any): CreateFormCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFormCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item);
        }
        if (Array.isArray(this.availableDates)) {
            data["availableDates"] = [];
            for (let item of this.availableDates)
                data["availableDates"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentMethods)) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item);
        }
        if (Array.isArray(this.availableLocations)) {
            data["availableLocations"] = [];
            for (let item of this.availableLocations)
                data["availableLocations"].push(item.toJSON());
        }
        data["formActive"] = this.formActive ? this.formActive.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["formType"] = this.formType;
        data["deliveryPrice"] = this.deliveryPrice;
        data["placeOnList"] = this.placeOnList;
        return data; 
    }
}

export interface ICreateFormCommand {
    name?: string | undefined;
    description?: string | undefined;
    positions?: string[] | undefined;
    availableDates?: AvailableDate[] | undefined;
    paymentMethods?: number[] | undefined;
    availableLocations?: Location[] | undefined;
    formActive?: AvailableDate | undefined;
    isActive: boolean;
    formType: FormTypeEnum;
    deliveryPrice?: number | undefined;
    placeOnList: number;
}

export class Location implements ILocation {
    name?: string | undefined;
    description?: string | undefined;
    street?: string | undefined;
    zipCode?: string | undefined;
    cityName?: string | undefined;
    countryName?: string | undefined;
    isDefault!: boolean;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.street = _data["street"];
            this.zipCode = _data["zipCode"];
            this.cityName = _data["cityName"];
            this.countryName = _data["countryName"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["street"] = this.street;
        data["zipCode"] = this.zipCode;
        data["cityName"] = this.cityName;
        data["countryName"] = this.countryName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface ILocation {
    name?: string | undefined;
    description?: string | undefined;
    street?: string | undefined;
    zipCode?: string | undefined;
    cityName?: string | undefined;
    countryName?: string | undefined;
    isDefault: boolean;
}

export enum FormTypeEnum {
    Event = 1,
    ForHere = 2,
    Delivery = 3,
}

export class UpdateFormCommand implements IUpdateFormCommand {
    id!: string;
    name?: string | undefined;
    description?: string | undefined;
    positions?: string[] | undefined;
    availableDates?: AvailableDate[] | undefined;
    paymentMethods?: number[] | undefined;
    availableLocations?: Location[] | undefined;
    formActive?: AvailableDate | undefined;
    isActive!: boolean;
    formType!: FormTypeEnum;
    deliveryPrice?: number | undefined;
    placeOnList!: number;

    constructor(data?: IUpdateFormCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions!.push(item);
            }
            if (Array.isArray(_data["availableDates"])) {
                this.availableDates = [] as any;
                for (let item of _data["availableDates"])
                    this.availableDates!.push(AvailableDate.fromJS(item));
            }
            if (Array.isArray(_data["paymentMethods"])) {
                this.paymentMethods = [] as any;
                for (let item of _data["paymentMethods"])
                    this.paymentMethods!.push(item);
            }
            if (Array.isArray(_data["availableLocations"])) {
                this.availableLocations = [] as any;
                for (let item of _data["availableLocations"])
                    this.availableLocations!.push(Location.fromJS(item));
            }
            this.formActive = _data["formActive"] ? AvailableDate.fromJS(_data["formActive"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.formType = _data["formType"];
            this.deliveryPrice = _data["deliveryPrice"];
            this.placeOnList = _data["placeOnList"];
        }
    }

    static fromJS(data: any): UpdateFormCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFormCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item);
        }
        if (Array.isArray(this.availableDates)) {
            data["availableDates"] = [];
            for (let item of this.availableDates)
                data["availableDates"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentMethods)) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item);
        }
        if (Array.isArray(this.availableLocations)) {
            data["availableLocations"] = [];
            for (let item of this.availableLocations)
                data["availableLocations"].push(item.toJSON());
        }
        data["formActive"] = this.formActive ? this.formActive.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["formType"] = this.formType;
        data["deliveryPrice"] = this.deliveryPrice;
        data["placeOnList"] = this.placeOnList;
        return data; 
    }
}

export interface IUpdateFormCommand {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    positions?: string[] | undefined;
    availableDates?: AvailableDate[] | undefined;
    paymentMethods?: number[] | undefined;
    availableLocations?: Location[] | undefined;
    formActive?: AvailableDate | undefined;
    isActive: boolean;
    formType: FormTypeEnum;
    deliveryPrice?: number | undefined;
    placeOnList: number;
}

export class FormAm implements IFormAm {
    id!: string;
    name?: string | undefined;
    description?: string | undefined;
    positions?: FormPosition[] | undefined;
    availableDates?: AvailableDate[] | undefined;
    paymentMethods?: PaymentMethodEnum[] | undefined;
    availableLocations?: Location[] | undefined;
    formActive?: AvailableDate | undefined;
    isActive!: boolean;
    formType?: string | undefined;
    deliveryPrice!: number;
    placeOnList!: number;

    constructor(data?: IFormAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions!.push(FormPosition.fromJS(item));
            }
            if (Array.isArray(_data["availableDates"])) {
                this.availableDates = [] as any;
                for (let item of _data["availableDates"])
                    this.availableDates!.push(AvailableDate.fromJS(item));
            }
            if (Array.isArray(_data["paymentMethods"])) {
                this.paymentMethods = [] as any;
                for (let item of _data["paymentMethods"])
                    this.paymentMethods!.push(item);
            }
            if (Array.isArray(_data["availableLocations"])) {
                this.availableLocations = [] as any;
                for (let item of _data["availableLocations"])
                    this.availableLocations!.push(Location.fromJS(item));
            }
            this.formActive = _data["formActive"] ? AvailableDate.fromJS(_data["formActive"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.formType = _data["formType"];
            this.deliveryPrice = _data["deliveryPrice"];
            this.placeOnList = _data["placeOnList"];
        }
    }

    static fromJS(data: any): FormAm {
        data = typeof data === 'object' ? data : {};
        let result = new FormAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item.toJSON());
        }
        if (Array.isArray(this.availableDates)) {
            data["availableDates"] = [];
            for (let item of this.availableDates)
                data["availableDates"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentMethods)) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item);
        }
        if (Array.isArray(this.availableLocations)) {
            data["availableLocations"] = [];
            for (let item of this.availableLocations)
                data["availableLocations"].push(item.toJSON());
        }
        data["formActive"] = this.formActive ? this.formActive.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["formType"] = this.formType;
        data["deliveryPrice"] = this.deliveryPrice;
        data["placeOnList"] = this.placeOnList;
        return data; 
    }
}

export interface IFormAm {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    positions?: FormPosition[] | undefined;
    availableDates?: AvailableDate[] | undefined;
    paymentMethods?: PaymentMethodEnum[] | undefined;
    availableLocations?: Location[] | undefined;
    formActive?: AvailableDate | undefined;
    isActive: boolean;
    formType?: string | undefined;
    deliveryPrice: number;
    placeOnList: number;
}

export class FormPosition implements IFormPosition {
    name?: string | undefined;
    description?: string | undefined;
    price!: number;
    vat!: number;
    amount!: number;
    portionSize?: string | undefined;

    constructor(data?: IFormPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.vat = _data["vat"];
            this.amount = _data["amount"];
            this.portionSize = _data["portionSize"];
        }
    }

    static fromJS(data: any): FormPosition {
        data = typeof data === 'object' ? data : {};
        let result = new FormPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["vat"] = this.vat;
        data["amount"] = this.amount;
        data["portionSize"] = this.portionSize;
        return data; 
    }
}

export interface IFormPosition {
    name?: string | undefined;
    description?: string | undefined;
    price: number;
    vat: number;
    amount: number;
    portionSize?: string | undefined;
}

export enum PaymentMethodEnum {
    OnPlace = 1,
    Przelewy24 = 2,
}

export class OrderListAm implements IOrderListAm {
    items?: OrderDetailsListAm[] | undefined;

    constructor(data?: IOrderListAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderDetailsListAm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderListAm {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderListAm {
    items?: OrderDetailsListAm[] | undefined;
}

export class OrderDetailsListAm implements IOrderDetailsListAm {
    id!: string;
    identityNumber!: number;
    purchaserName?: string | undefined;
    date!: Date;
    locationString?: string | undefined;
    isPaid!: boolean;
    needInvoice!: boolean;
    formId!: string;
    formName?: string | undefined;
    fullPrice!: number;
    description?: string | undefined;

    constructor(data?: IOrderDetailsListAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.identityNumber = _data["identityNumber"];
            this.purchaserName = _data["purchaserName"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.locationString = _data["locationString"];
            this.isPaid = _data["isPaid"];
            this.needInvoice = _data["needInvoice"];
            this.formId = _data["formId"];
            this.formName = _data["formName"];
            this.fullPrice = _data["fullPrice"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): OrderDetailsListAm {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailsListAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["identityNumber"] = this.identityNumber;
        data["purchaserName"] = this.purchaserName;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["locationString"] = this.locationString;
        data["isPaid"] = this.isPaid;
        data["needInvoice"] = this.needInvoice;
        data["formId"] = this.formId;
        data["formName"] = this.formName;
        data["fullPrice"] = this.fullPrice;
        data["description"] = this.description;
        return data; 
    }
}

export interface IOrderDetailsListAm {
    id: string;
    identityNumber: number;
    purchaserName?: string | undefined;
    date: Date;
    locationString?: string | undefined;
    isPaid: boolean;
    needInvoice: boolean;
    formId: string;
    formName?: string | undefined;
    fullPrice: number;
    description?: string | undefined;
}

export class CreateOrderCommand implements ICreateOrderCommand {
    purchaserName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    positions?: OrderPosition[] | undefined;
    date!: Date;
    locationName?: string | undefined;
    locationDescription?: string | undefined;
    street?: string | undefined;
    zipCode?: string | undefined;
    cityName?: string | undefined;
    countryName?: string | undefined;
    isDefault!: boolean;
    needInvoice?: boolean | undefined;
    paymentMethod?: PaymentMethodEnum | undefined;
    formId!: string;
    deliveryPrice!: number;
    description?: string | undefined;

    constructor(data?: ICreateOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaserName = _data["purchaserName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions!.push(OrderPosition.fromJS(item));
            }
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.locationName = _data["locationName"];
            this.locationDescription = _data["locationDescription"];
            this.street = _data["street"];
            this.zipCode = _data["zipCode"];
            this.cityName = _data["cityName"];
            this.countryName = _data["countryName"];
            this.isDefault = _data["isDefault"];
            this.needInvoice = _data["needInvoice"];
            this.paymentMethod = _data["paymentMethod"];
            this.formId = _data["formId"];
            this.deliveryPrice = _data["deliveryPrice"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaserName"] = this.purchaserName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item.toJSON());
        }
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["locationName"] = this.locationName;
        data["locationDescription"] = this.locationDescription;
        data["street"] = this.street;
        data["zipCode"] = this.zipCode;
        data["cityName"] = this.cityName;
        data["countryName"] = this.countryName;
        data["isDefault"] = this.isDefault;
        data["needInvoice"] = this.needInvoice;
        data["paymentMethod"] = this.paymentMethod;
        data["formId"] = this.formId;
        data["deliveryPrice"] = this.deliveryPrice;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateOrderCommand {
    purchaserName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    positions?: OrderPosition[] | undefined;
    date: Date;
    locationName?: string | undefined;
    locationDescription?: string | undefined;
    street?: string | undefined;
    zipCode?: string | undefined;
    cityName?: string | undefined;
    countryName?: string | undefined;
    isDefault: boolean;
    needInvoice?: boolean | undefined;
    paymentMethod?: PaymentMethodEnum | undefined;
    formId: string;
    deliveryPrice: number;
    description?: string | undefined;
}

export class OrderPosition implements IOrderPosition {
    name?: string | undefined;
    price!: number;
    vat!: number;
    amount!: number;
    portionSize?: string | undefined;

    constructor(data?: IOrderPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.price = _data["price"];
            this.vat = _data["vat"];
            this.amount = _data["amount"];
            this.portionSize = _data["portionSize"];
        }
    }

    static fromJS(data: any): OrderPosition {
        data = typeof data === 'object' ? data : {};
        let result = new OrderPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["price"] = this.price;
        data["vat"] = this.vat;
        data["amount"] = this.amount;
        data["portionSize"] = this.portionSize;
        return data; 
    }
}

export interface IOrderPosition {
    name?: string | undefined;
    price: number;
    vat: number;
    amount: number;
    portionSize?: string | undefined;
}

export class UpdateOrderCommand implements IUpdateOrderCommand {
    id!: string;
    purchaserName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    positions?: OrderPosition[] | undefined;
    date!: Date;
    locationName?: string | undefined;
    locationDescription?: string | undefined;
    street?: string | undefined;
    zipCode?: string | undefined;
    cityName?: string | undefined;
    countryName?: string | undefined;
    isDefault!: boolean;
    formId!: string;
    deliveryPrice!: number;
    description?: string | undefined;

    constructor(data?: IUpdateOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.purchaserName = _data["purchaserName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions!.push(OrderPosition.fromJS(item));
            }
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.locationName = _data["locationName"];
            this.locationDescription = _data["locationDescription"];
            this.street = _data["street"];
            this.zipCode = _data["zipCode"];
            this.cityName = _data["cityName"];
            this.countryName = _data["countryName"];
            this.isDefault = _data["isDefault"];
            this.formId = _data["formId"];
            this.deliveryPrice = _data["deliveryPrice"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["purchaserName"] = this.purchaserName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item.toJSON());
        }
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["locationName"] = this.locationName;
        data["locationDescription"] = this.locationDescription;
        data["street"] = this.street;
        data["zipCode"] = this.zipCode;
        data["cityName"] = this.cityName;
        data["countryName"] = this.countryName;
        data["isDefault"] = this.isDefault;
        data["formId"] = this.formId;
        data["deliveryPrice"] = this.deliveryPrice;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateOrderCommand {
    id: string;
    purchaserName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    positions?: OrderPosition[] | undefined;
    date: Date;
    locationName?: string | undefined;
    locationDescription?: string | undefined;
    street?: string | undefined;
    zipCode?: string | undefined;
    cityName?: string | undefined;
    countryName?: string | undefined;
    isDefault: boolean;
    formId: string;
    deliveryPrice: number;
    description?: string | undefined;
}

export class PositionListAm implements IPositionListAm {
    items?: PositionAm[] | undefined;

    constructor(data?: IPositionListAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PositionAm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PositionListAm {
        data = typeof data === 'object' ? data : {};
        let result = new PositionListAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPositionListAm {
    items?: PositionAm[] | undefined;
}

export class PositionAm implements IPositionAm {
    id!: string;
    identityNumber!: number;
    name?: string | undefined;
    description?: string | undefined;
    price!: number;
    vat!: number;
    amount!: number;
    portionSize?: string | undefined;
    positionCategory!: PositionCategoryEnum;

    constructor(data?: IPositionAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.identityNumber = _data["identityNumber"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.vat = _data["vat"];
            this.amount = _data["amount"];
            this.portionSize = _data["portionSize"];
            this.positionCategory = _data["positionCategory"];
        }
    }

    static fromJS(data: any): PositionAm {
        data = typeof data === 'object' ? data : {};
        let result = new PositionAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["identityNumber"] = this.identityNumber;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["vat"] = this.vat;
        data["amount"] = this.amount;
        data["portionSize"] = this.portionSize;
        data["positionCategory"] = this.positionCategory;
        return data; 
    }
}

export interface IPositionAm {
    id: string;
    identityNumber: number;
    name?: string | undefined;
    description?: string | undefined;
    price: number;
    vat: number;
    amount: number;
    portionSize?: string | undefined;
    positionCategory: PositionCategoryEnum;
}

export enum PositionCategoryEnum {
    Promotion = 1,
    Appetizer = 2,
    Soup = 3,
    MainCourse = 4,
    Vegetarian = 5,
    Drinks = 6,
    SelfMade = 7,
}

export class CreatePositionCommand implements ICreatePositionCommand {
    name?: string | undefined;
    description?: string | undefined;
    price!: number;
    vat!: number;
    amount!: number;
    portionSize?: string | undefined;
    positionCategory!: PositionCategoryEnum;

    constructor(data?: ICreatePositionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.vat = _data["vat"];
            this.amount = _data["amount"];
            this.portionSize = _data["portionSize"];
            this.positionCategory = _data["positionCategory"];
        }
    }

    static fromJS(data: any): CreatePositionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePositionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["vat"] = this.vat;
        data["amount"] = this.amount;
        data["portionSize"] = this.portionSize;
        data["positionCategory"] = this.positionCategory;
        return data; 
    }
}

export interface ICreatePositionCommand {
    name?: string | undefined;
    description?: string | undefined;
    price: number;
    vat: number;
    amount: number;
    portionSize?: string | undefined;
    positionCategory: PositionCategoryEnum;
}

export class UpdatePositionCommand implements IUpdatePositionCommand {
    id!: string;
    name?: string | undefined;
    description?: string | undefined;
    price!: number;
    vat!: number;
    amount!: number;
    portionSize?: string | undefined;
    positionCategory!: PositionCategoryEnum;

    constructor(data?: IUpdatePositionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.vat = _data["vat"];
            this.amount = _data["amount"];
            this.portionSize = _data["portionSize"];
            this.positionCategory = _data["positionCategory"];
        }
    }

    static fromJS(data: any): UpdatePositionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePositionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["vat"] = this.vat;
        data["amount"] = this.amount;
        data["portionSize"] = this.portionSize;
        data["positionCategory"] = this.positionCategory;
        return data; 
    }
}

export interface IUpdatePositionCommand {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    price: number;
    vat: number;
    amount: number;
    portionSize?: string | undefined;
    positionCategory: PositionCategoryEnum;
}

export class SaveSystemSettingsCommand implements ISaveSystemSettingsCommand {
    name?: string | undefined;
    description?: string | undefined;
    nip?: string | undefined;
    phoneNumber?: string | undefined;
    location?: Location | undefined;
    maxKmFromLocation!: number;
    globalDeliveryPrice!: number;

    constructor(data?: ISaveSystemSettingsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.nip = _data["nip"];
            this.phoneNumber = _data["phoneNumber"];
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.maxKmFromLocation = _data["maxKmFromLocation"];
            this.globalDeliveryPrice = _data["globalDeliveryPrice"];
        }
    }

    static fromJS(data: any): SaveSystemSettingsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SaveSystemSettingsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["nip"] = this.nip;
        data["phoneNumber"] = this.phoneNumber;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["maxKmFromLocation"] = this.maxKmFromLocation;
        data["globalDeliveryPrice"] = this.globalDeliveryPrice;
        return data; 
    }
}

export interface ISaveSystemSettingsCommand {
    name?: string | undefined;
    description?: string | undefined;
    nip?: string | undefined;
    phoneNumber?: string | undefined;
    location?: Location | undefined;
    maxKmFromLocation: number;
    globalDeliveryPrice: number;
}

export abstract class AuditableEntity implements IAuditableEntity {
    id!: string;
    identityNumber!: number;
    created!: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.identityNumber = _data["identityNumber"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["identityNumber"] = this.identityNumber;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data; 
    }
}

export interface IAuditableEntity {
    id: string;
    identityNumber: number;
    created: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class SystemSettings extends AuditableEntity implements ISystemSettings {
    name?: string | undefined;
    description?: string | undefined;
    nip?: string | undefined;
    phoneNumber?: string | undefined;
    location?: Location | undefined;
    maxKmFromLocation!: number;
    globalDeliveryPrice!: number;

    constructor(data?: ISystemSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.nip = _data["nip"];
            this.phoneNumber = _data["phoneNumber"];
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.maxKmFromLocation = _data["maxKmFromLocation"];
            this.globalDeliveryPrice = _data["globalDeliveryPrice"];
        }
    }

    static fromJS(data: any): SystemSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["nip"] = this.nip;
        data["phoneNumber"] = this.phoneNumber;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["maxKmFromLocation"] = this.maxKmFromLocation;
        data["globalDeliveryPrice"] = this.globalDeliveryPrice;
        super.toJSON(data);
        return data; 
    }
}

export interface ISystemSettings extends IAuditableEntity {
    name?: string | undefined;
    description?: string | undefined;
    nip?: string | undefined;
    phoneNumber?: string | undefined;
    location?: Location | undefined;
    maxKmFromLocation: number;
    globalDeliveryPrice: number;
}

export class AuthenticateResponse implements IAuthenticateResponse {
    id!: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    username?: string | undefined;
    token?: string | undefined;

    constructor(data?: IAuthenticateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.username = _data["username"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AuthenticateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["username"] = this.username;
        data["token"] = this.token;
        return data; 
    }
}

export interface IAuthenticateResponse {
    id: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    username?: string | undefined;
    token?: string | undefined;
}

export class AuthenticateRequest implements IAuthenticateRequest {
    username!: string;
    password!: string;

    constructor(data?: IAuthenticateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface IAuthenticateRequest {
    username: string;
    password: string;
}

export class WeatherForecast implements IWeatherForecast {
    date!: Date;
    temperatureC!: number;
    temperatureF!: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }
}

export interface IWeatherForecast {
    date: Date;
    temperatureC: number;
    temperatureF: number;
    summary?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}